"use strict"

const t = require("../../index.js")
const Util = require("../../test-util/assertions.js")
const fail = Util.fail
const basic = Util.basic

describe("assertions (type)", () => {
    describe("t.type()", () => {
        it("checks good types", () => {
            t.type(true, "boolean")
            t.type(false, "boolean")
            t.type(0, "number")
            t.type(1, "number")
            t.type(NaN, "number")
            t.type(Infinity, "number")
            t.type("foo", "string")
            t.type("", "string")
            t.type(null, "object")
            t.type({}, "object")
            t.type([], "object")
            t.type(() => {}, "function")
            t.type(undefined, "undefined")
            t.type(Symbol(), "symbol")
        })

        it("checks bad types", () => {
            fail("type", true, "nope")
            fail("type", false, "nope")
            fail("type", 0, "nope")
            fail("type", 1, "nope")
            fail("type", NaN, "nope")
            fail("type", Infinity, "nope")
            fail("type", "foo", "nope")
            fail("type", "", "nope")
            fail("type", null, "nope")
            fail("type", {}, "nope")
            fail("type", [], "nope")
            fail("type", () => {}, "nope")
            fail("type", undefined, "nope")
            fail("type", Symbol(), "nope")
        })
    })

    describe("t.notType()", () => {
        it("checks good types", () => {
            fail("notType", true, "boolean")
            fail("notType", false, "boolean")
            fail("notType", 0, "number")
            fail("notType", 1, "number")
            fail("notType", NaN, "number")
            fail("notType", Infinity, "number")
            fail("notType", "foo", "string")
            fail("notType", "", "string")
            fail("notType", null, "object")
            fail("notType", {}, "object")
            fail("notType", [], "object")
            fail("notType", () => {}, "function")
            fail("notType", undefined, "undefined")
            fail("notType", Symbol(), "symbol")
        })

        it("checks bad types", () => {
            t.notType(true, "nope")
            t.notType(false, "nope")
            t.notType(0, "nope")
            t.notType(1, "nope")
            t.notType(NaN, "nope")
            t.notType(Infinity, "nope")
            t.notType("foo", "nope")
            t.notType("", "nope")
            t.notType(null, "nope")
            t.notType({}, "nope")
            t.notType([], "nope")
            t.notType(() => {}, "nope")
            t.notType(undefined, "nope")
            t.notType(Symbol(), "nope")
        })
    })

    function testType(name, callback) {
        function check(name) {
            return t[name].bind(t)
        }

        function fail(name) {
            return fail.bind(undefined, name)
        }

        basic(`t.${name}()`, () => {
            callback(check(name), fail(name))
        })

        const negated = `not${name[0].toUpperCase()}${name.slice(1)}`

        basic(`t.${negated}()`, () => {
            callback(fail(negated), check(negated))
        })
    }

    testType("boolean", (is, not) => {
        is(true)
        is(false)
        not(0)
        not(1)
        not(NaN)
        not(Infinity)
        not("foo")
        not("")
        not(null)
        not({})
        not([])
        not(() => {})
        not(undefined)
        not()
        not(Symbol())
    })

    testType("number", (is, not) => {
        not(true)
        not(false)
        is(0)
        is(1)
        is(NaN)
        is(Infinity)
        not("foo")
        not("")
        not(null)
        not({})
        not([])
        not(() => {})
        not(undefined)
        not()
        not(Symbol())
    })

    testType("function", (is, not) => {
        not(true)
        not(false)
        not(0)
        not(1)
        not(NaN)
        not(Infinity)
        not("foo")
        not("")
        not(null)
        not({})
        not([])
        is(() => {})
        not(undefined)
        not()
        not(Symbol())
    })

    testType("object", (is, not) => {
        not(true)
        not(false)
        not(0)
        not(1)
        not(NaN)
        not(Infinity)
        not("foo")
        not("")
        is(null)
        is({})
        is([])
        not(() => {})
        not(undefined)
        not()
        not(Symbol())
    })

    testType("string", (is, not) => {
        not(true)
        not(false)
        not(0)
        not(1)
        not(NaN)
        not(Infinity)
        is("foo")
        is("")
        not(null)
        not({})
        not([])
        not(() => {})
        not(undefined)
        not()
        not(Symbol())
    })

    testType("symbol", (is, not) => {
        not(true)
        not(false)
        not(0)
        not(1)
        not(NaN)
        not(Infinity)
        not("foo")
        not("")
        not(null)
        not({})
        not([])
        not(() => {})
        not(undefined)
        not()
        is(Symbol())
    })

    testType("undefined", (is, not) => {
        not(true)
        not(false)
        not(0)
        not(1)
        not(NaN)
        not(Infinity)
        not("foo")
        not("")
        not(null)
        not({})
        not([])
        not(() => {})
        is(undefined)
        is()
        not(Symbol())
    })

    testType("true", (is, not) => {
        is(true)
        not(false)
        not(0)
        not(1)
        not(NaN)
        not(Infinity)
        not("foo")
        not("")
        not(null)
        not({})
        not([])
        not(() => {})
        not(undefined)
        not()
        not(Symbol())
    })

    testType("false", (is, not) => {
        not(true)
        is(false)
        not(0)
        not(1)
        not(NaN)
        not(Infinity)
        not("foo")
        not("")
        not(null)
        not({})
        not([])
        not(() => {})
        not(undefined)
        not()
        not(Symbol())
    })

    testType("null", (is, not) => {
        not(true)
        not(false)
        not(0)
        not(1)
        not(NaN)
        not(Infinity)
        not("foo")
        not("")
        is(null)
        not({})
        not([])
        not(() => {})
        not(undefined)
        not()
        not(Symbol())
    })

    testType("exists", (is, not) => {
        is(true)
        is(false)
        is(0)
        is(1)
        is(NaN)
        is(Infinity)
        is("foo")
        is("")
        not(null)
        is({})
        is([])
        is(() => {})
        not(undefined)
        not()
        is(Symbol())
    })

    testType("array", (is, not) => {
        not(true)
        not(false)
        not(0)
        not(1)
        not(NaN)
        not(Infinity)
        not("foo")
        not("")
        not(null)
        not({})
        is([])
        not(() => {})
        not(undefined)
        not()
        not(Symbol())
    })

    basic("t.instanceof()", () => {
        class A {}
        t.instanceof(new A(), A)
        t.instanceof(new A(), Object)

        class B extends A {}
        t.instanceof(new B(), B)
        t.instanceof(new B(), A)

        fail("instanceof", new A(), B)
        fail("instanceof", [], RegExp)
    })

    basic("t.notInstanceof()", () => {
        class A {}
        fail("notInstanceof", new A(), A)
        fail("notInstanceof", new A(), Object)

        class B extends A {}
        fail("notInstanceof", new B(), B)
        fail("notInstanceof", new B(), A)

        t.notInstanceof(new A(), B)
        t.notInstanceof([], RegExp)
    })
})
